# Redis
    - 고성능 오픈소스 메모리 Key/Value NoSQL 데이터베이스
    - 주요 사용 사례 : 캐싱, 세션 저장, Pub/Sub, 랭킹서버 등, 그리고 Channels의 ChannelLayer 백엔드
    - 다양한 자료구조를 지원
        - strings, Bitmatps, Hashes, Lists, Sets, Sorted Sets, Geoaspatial Indexes 등
    KEY "I'm a Plain Text String!"  # Strings
    KEY 00110101011001110010101010  # Bitmatps
    KEY {A: "foo", B: "bar", C: "baz"}  # Hashes
    KEY [ A -> B -> C -> D -> E]  # Lists
    KEY { A, B, C, D, E }  # Sets
    KEY { A: 0.1, B: 0.3, C: 100, D: 1337 }  # Sorted Sets
    KEY { A: (51.5, 0.12), B: (32.1, 34.7)}  # Geospatial Indexes

    - 서버 구동 방법
        - 외부 서비스를 활용
            - Redis Enterprise Cloud의 Free Plan (무료/유료)
            - 다양한 클라우드 벤더의 Redis as a Service 활용 (무료/유료)

        - 로컬에 직접 설치
            - 도커 활용
            - OS용 배포판 설치 (윈도우는 미지원이기에 WSL 활용)

    - 개발 및 실서비스용
        - 각 프로세스들이 네트워크를 통해 레디스를 공유하기에, 각 프로세스들을 같은 레이어로 동작시킬 수 있습니다.
        - channels_redis 라이브러리를 통해 제공

# 채널 레이어
- 서로 다른 프로세스 간에 메시지를 전달할 때, 중개자 역할
    - 주로 Consumer Instances에서 메시지를 소비/발행하지만,
    - 장고 뷰/모델, Celery Tasks를 비롯한 모든 장고 영역에서 메시지를 발행할 수 있음

    - 활용 예
        - 새로운 모델 인스턴스가 저장되면, 접속 유저에게 알리기(from 모델)
        - 긴 배치작업을 끝내고 나서, 접속 유저에게 알리기

- Channel Layer 백엔드
    - settings.CHANNEL_LAYERS 설정을 통해 설정
- 인메모리 (초기 개발용) : channels 기본에서 제공
    - 프로세스가 다수인 환경에서는 각 프로세스 별로 메모리가 격리되어 동작하기에, 프로세스 간 통신이 불가능합니다.
    - 단일 프로세스 배포 환경에서는 의미가 있습니다.

# 웹소켓에
    - 실시간 알림 목적으로만 사용하여, 복잡도를 줄여줌

# Liveblog
- group 기능 사용을 위해, 먼저 channel layer 설정이 필요합니다
    1. 블로그 정적 웹페이지 간단 구현
        - 포스팅이 생성/수정/삭제되면, 새로고침을 해야 화면에 반영됩니다.
    2. Post 모델에 대해, "liveblog" 그룹에 추가/수정/삭제 이벤트를 보냅니다.
    3. 웹소켓을 처리하는 Consumer를 /ws/liveblog/ 주소에 매핑하고, "liveblog" 그룹에 지정하고, 포스팅 추가/수정/삭제 이벤트를 받으면 웹소켓으로 전달합니다.
    4. 방문자들이 블로그 목록 웹페이지에 접속하면, /ws/liveblog/ 웹소켓에도 접속함
    5. 웹프론트에서는 이벤트 타입에 맞춰 분기하여 처리합니다.
        - 추가: 지정 post_id의 포스팅 내역을 웹서버로 HTTP 요청하여 응답을 받아 포스팅 목록에 추가합니다.
        - 수정: 지정 post_id의 포스팅 내역을 웹서버로 HTTP 요청하여 응답을 받아 포스팅 목록에 수정합니다.
        - 삭제: 지정 post_id의 포스팅을 포스팅 목로에서 삭제합니다.

# 채널 레이어로 전송할 수 있는 데이터 타입
- 어떤 인코딩/디코딩 방법이 사용되는 지?
    - 웹소켓 통신에서는 JSON 인코딩/디코딩이 많이 사용됨.
    - 채널 레이어에 값을 전달할 때에는 사전(dict) 타입의 값을 전달
    - type 필드가 지정되어야함
    - 그 외의 필드는 임의로 다양한 타입으로 추가할 수 있음

    - datetime 객체를 전송하려 한다면? = 직렬화(serialize) 에러가 발생함
        -> 이 때, msgpack 파이썬 라이브러리 활용
    - RedisChannelLayer의 serialize/deserialize 코드를 직접 살펴본다면,
    - 내부에서 msgpack 라이브러리의 packb 함수를 통해 직렬화 하고 있음
        = msgpack 라이브러리에서 지원하는 타입만 전송 가능함

    - msgpack은 JSON처럼 널리 사용되는 직렬화 방법 -> 수많은 언어에서 지원하고 있음
    - JSON은 문자열 포맷인데 반해, msgpack은 바이너리 포맷이기에 JSON에 비해 용량이 상대적으로 작음
    - 정수/실수/문자열/리스트/사전 등의 타입에 대해서만 기본 지원함
    = Extension 타입을 통해 커스텀 타입에 대한 변환을 지원
    - Extension 타입을 통해 datatime 타입을 문자열로 변환하는 방식으로 변환/역변환 룰을 추가할 수 있음
        - 변환 시에 default 키워드 인자를 통해 변환률을 구현한 함수를 지정
        - 역변환 시에는 ext_hook키워드 인자를 통해서 역변환룰을 구현한 함수를 지정

    - RedisChannelLayer에서는 msgpack에서 제공되는 기본 타입들로만 전송이 가능함
        - int, None, bool, float, str, bytes, list, dict


# Consumer 클래스 간 상속 관계

1. JsonWebsocketConsumer
    - send_json/recieve_json 에서도 지원을 통해 웹소켓 클라이언트와 통신 사에 json 인코딩/디코딩을 내부적으로 처리
2. WebsocketConsumer
    - 웹소켓 연결 및 메시지 송수신에 대한 기능 제공
    - 웹소켓 클라이언트와 통신 시에 직접 json 인코딩/디코딩 필요
3. SyncConsumer
    - AsyncConsumer의 동기 버전

1. AsyncJsonWebsocketConsumer
    - JsonWebsocektConsumer의 비동기 버전
2. AsyncWebsocektConsumer
    - WebsocketConsumer의 비동기 버전
    - 웹소켓 클라이언트와 통신 시에 직접 Json 인코딩/디코딩 필요

1. AsyncHttpConsumer
    - 비동기 HTTP Consumer
    - 하나의 요청/응답 방식은 장고 View를 통해 처리하고, 그 외 채널레이어 통합이 필요하거나,
      Server Sent Events 등을 구현할 때 필요

4. AstncConsumer ( 최상위 부모 클래스 )
    - 모든 Consumer 클래스의 부모 클래스 -> 비동기 구현이 네이티브
    - 채널 레이어 지원
    - 메시지 type에 따른 핸들러 호출을 구현

# SyncConsumer / AsyncConsumer
- 주로 Channels Worker를 구현할 목적으로 상속받습니다.
    - 채팅 서비스에서는 구현할 일이 없음
- 기본 Consumer 클래스
    - ASGI application spec 구현
    - 채널 레이어 처리
    - 메시지 type에 따른 핸들러 호출
- 지원할 메시지 type에 따른 메서드 만을 주로 구현

# WebsocketConsumer / AsyncWebsocektConsumer
- SyncConsumer / AsyncWebsocketConsumer 클래스 + 웹소켓 연결 및 메시지 송수신에 대한 기능을 추가 제공
- 연결 관리 메서드
    - connect(): 웹소켓 클라이언트와 연결 시점에 호출. 연결 수락 여부를 결정하기 위해 accept/close 메서드를 호출
    - accept(): connect 메서드 내에서 연결을 수락할 때 호출. 연결 거부는 close 호출.
    - close(code=None): 웹소켓 클라이언트와의 현 연결을 끊고자 할 때 호출
    - disconnect(code): 웹소켓 클라이언트와 연결이 끊어졌을 때 호출

- 메시지 송/수신 메서드
    - receive(text_data=None, bytes_data=None): 웹소켓 클라이언트로부터 메시지를 받았을 때 호출
    - send(text_data=None, bytes_data=None, close=False): 웹소켓 클라이언트 메시지를 보낼 때 호출

- 연결 요청이 들어오면 connect 메서드가 호출
- 연결을 수락하면 self.accept()를 호출하면 웹소켓 연결이 맺어짐
- 연결을 거부한다면 self.close()를 호출
- 연결이 끊어지면 disconnect 메서드가 호출
- 웹소켓 연결이 유지되다가, 클라이언트 단에서 연결을 끊을 수도 있고, 서버 단에서 웹소켓 연결을 끊고자 할 때에 self.close()를 호출
- 웹소켓 클라이언트로부터 메시지를 수실할 때마다 receive 메서드가 호출

- 송신시에는 send 메서드를 사용. 메세지 송수신 시에는 직접 JSON 인코딩/디코딩을 수행하여 문자열 형태로 통신해야만 함

# JsonWebsocketConsumer / AsyncJsonWebsocketConsumer
- send_json/receive_json 메서드를 추가 지원
    - 웹소켓에서 주로 JSON 통신이기에, 가장 많이 사용하게될 Consumer 클래스
- 메시지 송/수신 메서드
- receive_json(content, **kwargs)
    - text_data에 한해서 receive 메서드에 의해 호출되며 json인코딩된 메시지를 인자로 받음.
- send_json(content, close_False)
    - json 디코딩 문자열을 send 메서드의 text_data 인자로 호출
    

